/*
Continuation stacks for Node.js

SuperStack copyright (c) 2013 by ddsol

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

var gStack=null;

function stackPush(v8,isBranch){
  return {v8:v8,tail:gStack,isBranch:!!isBranch};
}

function pushStack(v8,isBranch){
  gStack=stackPush(v8,isBranch);
}

function popStack(){
  if (gStack) {
    gStack=gStack.tail;
  } else {
    throw new Error('Stack underrun!');
  }
}

function getFullv8Stack(dropcount){
  var orig = Error.prepareStackTrace;
  Error.prepareStackTrace = function(_, stack){ return stack; };
  var err = new Error;
  Error.captureStackTrace(err, arguments.callee);
  var s = err.stack;
  Error.prepareStackTrace = orig;
  err=null;
  dropcount=(dropcount|0)+1;
  while (dropcount) {
    dropcount--;
    s.shift();
  }
  return s;
}

function getv8stackUpToMostRecentWrapCbInternal(dropcount,stack){
  dropcount=(dropcount|0)+1;
  var s=stack||getFullv8Stack(dropcount),ret;
  for (var i=0;i<s.length;i++){
    if (!s[i].getFunctionName) continue; //a branch, apparently
    if (s[i].getFunctionName()=='__wrapCbInternal__' || s[i].getMethodName()=='__wrapCbInternal__') {
      ret=s.slice(0,i)
      return ret;
    }
  }
  return s;
}

function suspend(removalDepth){
  return stackPush(getv8stackUpToMostRecentWrapCbInternal(1+(removalDepth|0)));
}

function unwind(stack){
  result=[];
  while (stack) {
    if (stack.isBranch) {
      result.push(new Branch(stack.v8));
    } else {
      stack.v8.forEach(function(frame){
        result.push(frame);
      });
    }
    stack=stack.tail;
  }
  return result;
}

function resume(stack,removalDepth){
  var lStack=gStack;
  gStack=stack;
  pushStack(getFullv8Stack(removalDepth).concat(unwind(lStack)),true);
}

function leave(si){
  gStack=si;
  popStack();
}

function Branch(v8){
  this.v8=v8;
}

function augment(v8,stack){
  if (!stack) return augment(v8,gStack);
  var aug=v8;
  while (stack) {
    if (stack.isBranch) {
      aug.push(new Branch(stack.v8))
    } else {
      stack.v8.forEach(function(frame){
        aug.push(frame)
      });
    }
    stack=stack.tail;
  }
  return aug;
}

function wrapCb(cb,ctx,preRemovalDepth,postRemovalDepth,viaName){ //all but the callback are optional.
  if (!Error.deepTrace) return cb.bind(ctx);
  var args=arguments;
  (function(){
    var c,br,ar,vn,a,t;
    for (var i=args.length-1;i>=1;i--){
      a=args[i];
      t=typeof a;
      if (t=='string') {
        vn=a;
      } else if (t=='number') {
        if (br===undefined) {
          br=a;
        } else {
          ar=br;
          br=a;
        }
      } else {
        c=a;
      }
    }
    ctx=c;
    preRemovalDepth=br;
    postRemovalDepth=ar;
    viaName=vn;
  }());
  
  var si=suspend(preRemovalDepth);
  return __wrapCbInternal__;
  
  function __wrapCbInternal__(){
    function augErr(err){
      if (err.superStack) return; //already processed
      var s=err.stack;
      err.rawStack=getv8stackUpToMostRecentWrapCbInternal(0,err.rawStack);
      err.superStack=augment(err.rawStack,gStack);
      err.stack=prepTrace(err,err.rawStack,viaName); //redo stack prep (we have a superStack now)
    }
    resume(si,1+(postRemovalDepth|0));
    if (arguments[0] instanceof Error) { //assume first is error, but check :)
      augErr(arguments[0]); //augment the error with a more powerful stack...
    }
    if (!ctx) ctx=this;
    try {
      cb.apply(ctx,arguments);
    } catch(err) {
      augErr(err);
      throw err;
    } finally {
      leave(si);
    }
  }
}

var prepTrace;

function initError(){
  Error.stackTraceLimit=100; //So we can reach across to the other side :)
  prepTrace=superStackPrepTrace;
  
  if (Error.prepareStackTrace && Error.prepareStackTrace.name=='superStackPrepTrace') return; //Multiple require calls?

  var prev=Error.prepareStackTrace;
  
  Error.prepareStackTrace=superStackPrepTrace;
  
  function superStackPrepTrace(err,rawStack,viaName){
    if (!Error.deepTrace) return makeNormal(); //uses the standard as well (don't have to actually call stack again)
    err.rawStack=rawStack;
    if (err.rawOnly) return ' ';
    var trace;
    if (!err.superStack) { //produce a regular trace... we don't have enough info.
      return makeNormal();
    }
    cleanStack(err.superStack);
    wrapCb.clean(err.superStack);
    //since we DO have a superstack, let's decide on what kind of stack to produce:
    var kind=Error.traceKind||'normal';
    if (kind=='tree') {
      trace=header()+indent(makeTree(err.superStack)).join('\n');
    } else if (kind=='continuable') {
      trace=header()+indent(makeContinuable(err.superStack)).join('\n');
    } else { //normal or other
      trace=makeNormal();
    }
    return trace;
    
    function indent(l){
      for (var i=0;i<l.length;i++) {
        l[i]='  '+l[i];
      }
      return l;
    }
    
    function makeVia(stack,forceGood){
      if (viaName) return 'via '+viaName
      //Detect what event caused this and return a 'via' line
      var last=stack.length-1,prev=last-1;
      if (last>=0) {
        var lastline='via '+stack[last];
        var prelast=''+stack[prev];
        if (lastline.indexOf('timers.js:')>=0) return 'via timer event';
        if (prelast.indexOf('timers.js:')>=0) return 'via timer event';
        if (lastline.indexOf('process._tickCallback')>=0) return 'via tick event';
        if (lastline.indexOf('net.js:')>=0) return 'via network event';
        if (lastline.indexOf('fs.js')>=0) return 'via file system event';
        //Probably could add a lot more here...
        if (!forceGood) 
          return lastline;
      }
      return 'via event';
    }
    
    function cleanSub(sub){
      var line;
      for (var i=sub.length-1;i>=0;i--){
        line=''+sub[i];
        sub[i]=line.replace(/null\._onTimeout/,'timeout handler');
        if (!/timers\.js|process\._tickCallback|fs\.js/.exec(line)) { //only clean ones that we have a descriptive "via" for in makeVia()
          break;
        }
      }
      sub.splice(i+1,sub.length-i);
      for (var i=sub.length-1;i>=0;i--){
        line=''+sub[i];
        line=line.replace(/null\._onTimeout/,'timeout handler');
        if (/timers\.js|process\._tickCallback/.exec(line)) {//delete
          sub.splice(i,1);
          continue;
        }
        sub[i]=line;
      }
    }
    
    function makeTree(stack,skipBranches){
      var trace=[];
      for (var i=0;i<stack.length;i++){
        var frame=stack[i];
        if (frame instanceof Branch) {
          //add a 'via'
          trace.push(makeVia(frame.v8,!skipBranches));
          if (!skipBranches) {
            var sub=makeTree(frame.v8,skipBranches);
            cleanSub(sub);
            trace=trace.concat(sub);
          }
        } else {
          trace.push('at '+frame);
        }
      }
      indent(trace);
      return trace;
    }
    
    function makeContinuable(stack){
      return makeTree(stack,true);
    }
    
    function header(){
      return err.name+': '+err.message+'\n';
    }
    
    function makeNormal(){
      Error.prepareStackTrace=prev;
      trace=err.stack;
      Error.prepareStackTrace=superStackPrepTrace;
      return trace;
    }
  }
}

initError();

wrapCb.clean=function(){};

function cleanStack(stack){
  return;
  for (var i=stack.length-1;i>=0;i--){
    if (stack[i] instanceof Branch) {
      cleanStack(stack[i].v8);
      continue;
    }
    
    if (stack[i].getFileName && stack[i].getFileName()==__filename)
     stack.splice(i,1);
  }
};

wrapCb.Branch=Branch; //so others can use instanceof in clean()
Error.deepTrace=true;

module.exports=wrapCb;